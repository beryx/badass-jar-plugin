// Settings:
:idprefix:
:idseparator: -
ifndef::env-github[:icons: font]
ifdef::env-github,env-browser[]
:toc: macro
:toclevels: 1
endif::[]
ifdef::env-github[]
:branch: master
:status:
:outfilesuffix: .adoc
:!toc-title:
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

http://makeapullrequest.com:[image:https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square[PRs Welcome]]
https://github.com/beryx/badass-jar-plugin/blob/master/LICENSE[image:https://img.shields.io/badge/License-Apache%202.0-blue.svg[License]]
https://github.com/beryx/badass-jar-plugin/actions?query=workflow%22build%22[image:https://img.shields.io/github/workflow/status/beryx/badass-jar-plugin/build[Build Status]]

== Badass Jar Plugin

This plugin lets you seamlessly create modular jars that target a Java release before 9.
This way, your library can be used not only by people who build JPMS applications, but also by people who are still using Java 8 or older releases.


=== Prerequisites
The plugin requires Gradle 7.1 or newer. For older Gradle releases you can use https://github.com/beryx/badass-jar-plugin/tree/version-1.x[version 1.2.0] of this plugin.

Note that your build can create a modular jar even when using a Java 7 or 8 toolchain.
This is possible because in this case the plugin assembles the module descriptors without using the java compiler.


=== Usage

To use the plugin, include the following in your build script:
[source,groovy]
----
plugins {
    id 'java'
    id 'org.beryx.jar' version '2.0.0-rc-3'
}
----

The plugin uses an extension named `moduleConfig`. The sample below shows a few configuration options.
[source,groovy]
----
moduleConfig {
    moduleInfoPath = 'src/main/module/module-info.java'
    multiRelease = true
    moduleInfoCompatibility = 9
    version = project.version
}
----

Since all properties have default values, the `moduleConfig` block may be missing.

To make your library modular, you need to provide a `module-info.java`, which usually resides in the project's main java source directory.
If the version of your java toolchain is greater than 8, the plugin compiles this file using the java compiler.
Otherwise, it uses the https://github.com/javaparser/javaparser[JavaParser] to analyze the `module-info.java` file and the https://asm.ow2.io/[ASM] bytecode manipulation framework to generate the corresponding module descriptor.
Note that in this later case, the plugin cannot validate your module descriptor.
References to nonexistent packages, modules, services, or service implementations go undetected.

Therefore, you should use a Java 9+ toolchain whenever it's possible.

The properties provided by the `moduleConfig` extension are described below.

==== _multiRelease_ : enable/disable Multi-release JAR
[purple]##default value: ## `true`

Typically, a https://openjdk.java.net/projects/jigsaw/spec/sotms/#module-artifacts[modular jar]
includes the `module-info.class` file in its root directory.
This causes problems for some older tools, which incorrectly process the module descriptor as if it were a normal Java class.
To provide the best backward compatibility, the plugin creates by default a
https://openjdk.java.net/jeps/238#Modular-multi-release-JAR-files[modular multi-release jar]
with the `module-info.class` file located in `META-INF/versions/9`, as shown below.

image:https://raw.githubusercontent.com/beryx/badass-jar-plugin/master/doc/multi-release-jar.png[multi-release-jar,548,200]

You can prevent the creation of a multi-release jar by setting the `multiRelease` property to `false` in the `moduleConfig` extension:

[source,groovy]
----
moduleConfig {
    multiRelease = false
    ...
}
----

==== _moduleInfoCompatibility_: configure module descriptor location
[purple]##default value: ## `9`

When creating a multi-release jar, the plugin puts by default the `module-info.class` file in the `META-INF/versions/9` folder, which means that any JVM with version >= 9 will handle this jar as modular. You can change this by setting the `moduleInfoCompatibility` property in the `moduleConfig` extension. For example, the code below instructs the plugin to put the module descriptor in the `META-INF/versions/11` folder.

[source,groovy]
----
moduleConfig {
    moduleInfoCompatibility = 11
}
----


==== _moduleInfoPath_: configure module-info.java location
[purple]##default value: ## `src/main/java/module-info.java`

As mentioned before, this plugin lets you create a modular jar even if you use a Java 7 or 8 toolchain.
However, your IDE may complain  about the presence of `module-info.java` in your source directory when using a pre-Java 9 compiler.
To avoid this situation, you can tell the plugin to retrieve the module descriptor from another location.
You do this by setting the `moduleInfoPath` property in the `moduleConfig` extension:

[source,groovy]
----
moduleConfig {
    moduleInfoPath = 'src/main/module/module-info.java'
    ...
}
----

You should avoid using property when using a java toolchain with a version >= 9.

==== _version_: configure module version
[purple]##default value: ## _empty_ (no module version will be set)

You can specify a version for your module by setting the `version` property in the `moduleConfig` extension:

[source,groovy]
----
moduleConfig {
    version = '2.3.4'
    ...
}
----

=== Examples

The following projects illustrate how to use this plugin to create modular jars targeted to pre-Java 9 releases:

- https://github.com/beryx-gist/badass-jar-example-nqueens[badass-jar-example-nqueens]: a Java library for solving the N-Queens problem.
- https://github.com/beryx-gist/badass-jar-example-nqueens-kotlin[badass-jar-example-nqueens-kotlin]: a Kotlin library for solving the N-Queens problem.

=== Acknowledgements

This plugin was heavily inspired by and includes code from
Gunnar Morling's https://github.com/moditect/moditect#adding-a-module-descriptor-to-the-project-jar[moditect] tool.
